import{_ as e}from"./Step.vue_vue_type_script_setup_true_lang-0c86fd90.js";import{f as l,o as c,c as r,a,b as s,u as t,d as i}from"./index-3b657d1a.js";const o="/assets/opengl_a-261bf2d1.png",n="/assets/opengl_b-b440cbd5.png",d="/assets/opengl_c-5e3508af.png",p="/assets/ionia-c2ccfa14.jpg",x="/assets/opengl_i-f52f911c.png",f="/assets/opengl_j-f6b1ba78.png",v="/assets/opengl_l-283c78c5.png",m="/assets/opengl_m-7ff6a043.png",b="/assets/opengl_n-182b3702.png",g="/assets/opengl_o-10fd9c20.png",h="/assets/opengl_p-b15f9b77.png",w="/assets/opengl_q-3f27d34f.png",_="/assets/opengl_r-9a6e825f.png",y="/assets/opengl_s-c9068f06.png",u="/assets/opengl_t-02c5f70f.png",j="/assets/opengl_u-6446e618.png",k="/assets/opengl_v-447fad0e.png",P="/assets/opengl_f-00bb0e9c.png",S="/assets/opengl_g-1f78ee96.png",V="/assets/opengl_h-61dcce66.png",K="/assets/opengl_k-c5362dac.png",N={class:"relative px-20"},C=i('<div class="relative my-24"><div class="flex justify-center items-center h-48 w-1/2 m-auto"><div class="absolute inset-0 h-48 bg-white bg-opacity-90"></div><h1 class="relative font-bold text-5xl text-opcity-100">OpenGL渲染器​</h1></div></div><div class="relative my-24"><h2 class="text-4xl text-center font-bold pb-8">目標 </h2><div class="flex items-center justify-center"><p class="text-center text-2xl w-1/2">輸入物件的obj檔、mtl檔以及textures，並用OpenGL實作出該物件在point light、direction light以及spot light下的渲染效果</p></div></div><div class="relative my-24"><div class="flex justify-center my-12"><div class="flex flex-col w-48 h-36 justify-center text-center items-center mr-24"><h3 class="text-2xl font-bold pb-2"> 作者</h3><p class="break-words"> 吳少森 、吳昱霆教授 </p></div><div class="flex flex-col w-48 h-36 justify-center text-center items-center"><h3 class="text-2xl font-bold pb-2"> 開發環境</h3><p class="break-words"> Visual Studio<br> FreeGLUT </p></div></div></div><div class="relative my-24"><h2 class="text-4xl text-center font-bold pb-8">實作流程 </h2><div class="flex items-center justify-center"><div class="flex flex-col items-start text-2xl"><a href="#section1">A.讀檔並把物件處理成一個一個的三角形</a><a href="#section2">B.進入vertex shader，以及rasterizer​</a><a href="#section3">C.進入fragment shader，並用Phong reflection model實作出光線效果​</a></div></div></div><hr class="border-gray-200 my-20"><div class="relative px-20 my-24"><h2 class="text-3xl text-center font-bold pb-8">檔案介紹 </h2><div class="flex flex-col my-10 py-3"><div class="flex items-center justify-between px-24"><div><h3 class="text-2xl font-bold">obj檔</h3><p class="break-words w-72"> mtllib(material library)-&gt;宣告mtl檔。<br> v(vertex)-&gt;宣告vertex的三維座標。<br> vt(vertex texture)-&gt;宣告texture的座標。<br> vn(vertex normal)-&gt;宣告一個法向量。<br> usemtl(use material)-&gt;宣告接下來的平面要用哪種mtl。<br> f(face)-&gt;宣告一個至少由三個點組成平面，每個點會由P/T/N組成，分別是postion/texture/normal的index。<br></p></div><div class="w-3/5 flex justify-center"><img src="'+o+'" class="h-80 w-50"><img src="'+n+'" class="h-80 w-50"></div></div></div><div class="flex flex-col my-10 py-3"><div class="flex items-center justify-between px-24"><div><h3 class="text-2xl font-bold">mtl檔</h3><p class="break-words w-72"> newmtl(new material)-&gt;宣告接下來要定義一個新的mtl。<br> Ns(specular exponent)-&gt;用來表示高光的大小。<br> Ka(Ambient Coefficient)-&gt;用來表示環境光(無向光)的反射強度。<br> Kd(Diffuse Coefficient)-&gt;用來表示有向光的漫射強度。<br> Ks(Specular Coefficient)-&gt;用來表示有向光的反射強度。<br> map_kd-&gt;宣告使用texture來表示Kd。<br></p></div><div class="w-3/5 flex justify-center"><img src="'+d+'"></div></div></div><div class="flex flex-col my-10 py-3"><div class="flex items-center justify-between px-24"><div><h3 class="text-2xl font-bold">texture</h3><p class="break-words"> 一張2d圖片<br></p></div><div class="w-3/5 flex justify-center"><img src="'+p+'" class="h-80 w-50"></div></div></div></div>',6),B={class:"relative px-20 my-24",id:"section1"},G=i('<h2 class="text-3xl text-center font-bold pb-8">Process A </h2><div class="flex flex-col my-10 py-3 px-20"><div class="flex items-center justify-between px-24"><h3 class="text-2xl font-bold">step.1</h3><p class="break-words h-1/5 w-3/5">讀入material library(Ka、Kd、Ks、texture)、v、vt、vn。</p></div></div>',2),L=i('<div class="relative px-20 my-24" id="section2"><h2 class="text-3xl text-center font-bold pb-8">Process B </h2><div class="flex flex-col my-10 py-3"><div class="flex items-center justify-between px-24"><div><h3 class="text-2xl font-bold">step.1</h3><p class="break-words w-72">定義MVP(model-view-projection)矩陣。</p></div><p class="break-words h-1/5 w-3/5"> MVP = M*V*P。<br><br> M(model matrix/world matrix)-&gt;把物件從object space轉成world space，包括位移、旋轉、縮放。<br><br> V(view matrix)-&gt;把物件從world space轉成view space(以camera為原點的space)。<br><br> P(project matrix)-&gt;把物件從view space轉成clip space，進行perspective projection把3D座標投影到2D。 </p></div></div><div class="flex flex-col my-10 py-3"><div class="flex items-center justify-between px-24"><div><h3 class="text-2xl font-bold">step.2</h3><p class="break-words w-72"> 定義vertex shader。<br><br> gl_Postion-&gt;把物件的座標從object space轉成clip space。<br> interpPos-&gt;world space的座標。<br> interpNor-&gt;把object space的法向量乘上normal matrix(world matrix的反矩陣再轉置)，得到物件在world space的法向量。<br> interpTexcoord-&gt;texture的座標。 </p></div><div class="w-3/5 flex justify-center"><img src="'+x+'"></div></div></div><div class="flex flex-col my-10 py-3"><div class="flex items-center justify-between px-24"><div><h3 class="text-2xl font-bold">step.3</h3><p class="break-words w-72"> rasterization。<br><br> 透過內插計算出三角形內每個pixel的postion、texture、normal。<br> 刪掉在螢幕範圍外的或是被擋住的pixel後，剩下的被稱為fragment並送入fragment shader。 </p></div><div class="w-2/5 flex justify-center"><img src="'+f+'"></div></div></div></div><div class="relative px-20 my-24" id="section3"><h2 class="text-3xl text-center font-bold pb-8">Process C </h2><div class="flex flex-col my-10 py-3"><div class="flex items-center justify-between px-24"><div><h3 class="text-2xl font-bold">step.1 </h3><p class="break-words w-72"> 定義diffuse跟specular reflection的計算方法。 </p></div><div class="w-3/5 flex justify-center"><img src="'+v+'"></div></div></div><div class="flex flex-col my-10 py-3"><div class="flex items-center justify-between px-24"><div><h3 class="text-2xl font-bold">step.2 </h3><p class="break-words w-72"> 定義point light的計算方法。 </p></div><div class="w-3/5 flex justify-center"><img src="'+m+'"></div></div></div><div class="flex flex-col my-10 py-3"><div class="flex items-center justify-between px-24"><div><h3 class="text-2xl font-bold">step.3 </h3><p class="break-words w-72"> 定義direction light的計算方法。 </p></div><div class="w-3/5 flex justify-center"><img src="'+b+'"></div></div></div><div class="flex flex-col my-10 py-3"><div class="flex items-center justify-between px-24"><div><h3 class="text-2xl font-bold">step.4 </h3><p class="break-words w-72"> 定義spot light的計算方法。 </p></div><div class="w-3/5 flex justify-center"><img src="'+g+'"></div></div></div><div class="flex flex-col my-10 py-3"><div class="flex items-center justify-between px-24"><div><h3 class="text-2xl font-bold">step.5 </h3><p class="break-words w-72"> 把有向光源的影響以及環境光加總起來，就能算出該fragment的顏色。 </p></div><div class="w-3/5 flex justify-center"><img src="'+h+'"></div></div></div></div><hr class="border-gray-200"><div class="relative my-24" id="section2"><h2 class="text-4xl text-center font-bold my-12">成果展示</h2><div class="flex flex-col items-center justify-center"><p class="text-xl text-center">紅點是point light，黃點是spot light</p><div class="flex items-center justify-between w-3/5 py-12"><img src="'+w+'" class="h-1/5 w-2/5"><img src="'+_+'" class="h-1/5 w-2/5"></div><div class="flex items-center justify-between w-3/5 py-12"><img src="'+y+'" class="h-1/5 w-2/5"><img src="'+u+'" class="h-1/5 w-2/5"></div><div class="flex items-center justify-between w-3/5 py-12"><img src="'+j+'" class="h-1/5 w-2/5"><img src="'+k+'" class="h-1/5 w-2/5"></div></div></div>',4),z=l({__name:"OpenGL",setup(M){return(T,A)=>(c(),r("div",N,[C,a("div",B,[G,s(e,{step:"step.2",description:"讀入f並通過PTN的index得到vertex positon/texture/normal的值",imageSrc:t(P)},null,8,["step","imageSrc"]),s(e,{step:"step.3",description:"如果f的點超過3個，就把f拆成多個三角形",imageSrc:t(S)},null,8,["step","imageSrc"]),s(e,{step:"step.4",description:"找出物件的中心及三個維度的最長邊",imageSrc:t(V)},null,8,["step","imageSrc"]),s(e,{step:"step.5",description:"以物件中心為原點，將每個面的position標準化成-0.5~0.5的值",imageSrc:t(K)},null,8,["step","description","imageSrc"])]),L]))}});export{z as default};
